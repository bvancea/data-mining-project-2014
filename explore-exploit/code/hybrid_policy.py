#!/usr/bin/env python2.7
from numpy.linalg import inv

import numpy as np
from sklearn import preprocessing


ALPHA = 3.0
USER_FEATURES_NR = 6

a_0 = np.identity(USER_FEATURES_NR)
b_0 = np.zeros(USER_FEATURES_NR)

x_a = {}
a_a = {}
B_a = {}
b_a = {}

a_0_inv = inv(a_0)
a_a_inv = {}
weight = {}
beta = a_0_inv.dot(b_0)

last_aid = 0
last_user = None

ucb = None
w = None

scaler = preprocessing.StandardScaler()

giant_matrix_1 = {}
giant_matrix_2 = {}


# Evaluator will call this function and pass the article features.
# Check evaluator.py description for details.
def set_articles(art):
    global a_a, a_a_inv, b_a, x_a, weight, giant_matrix_1, giant_matrix_2
    #initialize values
    for article_id in art:
        d = len(art[article_id])
        x_a[article_id] = scaler.fit_transform(np.array(art[article_id]))
        a_a[article_id] = np.identity(d)
        a_a_inv[article_id] = inv(a_a[article_id])

        B_a[article_id] = np.zeros((USER_FEATURES_NR, d))
        b_a[article_id] = np.zeros(d)

        weight[article_id] = a_a_inv[article_id].dot((b_a[article_id] - B_a[article_id].dot(beta)))

        giant_matrix_1[article_id] = a_a_inv[article_id].dot(x_a[article_id])
        giant_matrix_2[article_id] = a_0_inv.\
                                    dot(B_a[article_id].transpose()).\
                                    dot(a_a_inv[article_id]).\
                                    dot(x_a[article_id])


# This function will be called by the evaluator.
# Check task description for details.
def update(reward):
    global a_0, b_0, a_a, b_a, B_a, a_0_inv, beta, giant_matrix_1, giant_matrix_2
    aa_inv = a_a_inv[last_aid]
    Ba_t = B_a[last_aid]
    a_0 += Ba_t.transpose().dot(aa_inv).dot(B_a[last_aid])
    b_0 += Ba_t.transpose().dot(aa_inv).dot(b_a[last_aid])

    xa_t = x_a[last_aid]
    a_a[last_aid] += np.inner(xa_t, xa_t)
    a_a_inv[last_aid] = inv(a_a[last_aid])
    aa_inv = a_a_inv[last_aid]

    B_a[last_aid] += xa_t.dot(last_user.transpose())
    b_a[last_aid] += reward * xa_t

    #todo precompute b_a_t_tr * aa_inv
    a_0 += np.inner(last_user, last_user) - \
           B_a[last_aid].transpose().dot(aa_inv).dot(B_a[last_aid])

    a_0_inv = inv(a_0)

    b_0 += reward * last_user - \
           B_a[last_aid].transpose().dot(aa_inv).dot(b_a[last_aid])

    beta = a_0_inv.dot(b_0)
    weight[last_aid] = a_a_inv[last_aid].dot((b_a[last_aid] - B_a[last_aid].dot(beta)))

    giant_matrix_1[last_aid] = a_a_inv[last_aid].dot(x_a[last_aid])
    giant_matrix_2[last_aid] = a_0_inv.\
                                dot(B_a[last_aid].transpose()).\
                                dot(a_a_inv[last_aid]).\
                                dot(x_a[last_aid])

# This function will be called by the evaluator.
# Check task description for details.
def reccomend(timestamp, user_features, articles):
    global last_user, last_aid
    z_t = np.array(user_features)

    max_ucb = None
    max_ucb_id = None
    s_t_a = None

    #compute UCB score for all articles
    for article_id in articles:
        #compute the UCB score

        s_t_a = z_t.transpose().dot(a_0_inv).dot(z_t) -\
                2 * z_t.transpose().\
                    dot(giant_matrix_2[article_id]) +\
                x_a[article_id].transpose().\
                    dot(giant_matrix_1[article_id]) +\
                x_a[article_id].transpose().\
                    dot(a_a_inv[article_id]).\
                    dot(B_a[article_id]).\
                    dot(giant_matrix_2[article_id])
        ucb = z_t.transpose().dot(beta) + x_a[article_id].dot(weight[article_id]) + ALPHA * np.sqrt(s_t_a)

        #find the max
        if max_ucb is None or max_ucb < ucb:
            max_ucb = ucb
            max_ucb_id = article_id

    last_user = z_t
    last_aid = max_ucb_id
    #pick article with best score
    return max_ucb_id
